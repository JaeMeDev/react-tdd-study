## 1. 테스트를 하는 이유

왜 어플리케이션을 TEST 해야 할까?

- 간단하게 더 안정적인 어플리케이션을 위해서는 여러 방법으로 테스트를 해줘야 더 안정적인 어플리케이션이 될 수 있다.

테스팅으로 얻는 이점은 무엇일까?

- 디버깅 시간을 단축할 수 있다. 만약 데이터가 잘못 나왔다면 그것이 UI문제인지 DB 문제인지 등 전부 테스트를 해봐서 찾아야 하는데 테스팅 환경이 구축되어 있다면 자동화 된 유닛 테스팅으로 특정 버그를 쉽게 찾아 낼 수 있다.
- 더욱 안정적인 어플리케이션 개발이 가능하다. 많은 테스트 코드와 함께 작성된 코드의 어플리케이션이 되기 때문에 훨씬 안정적인 어플리케이션이 된다.
- 이 밖에 재설계 시간의 단축, 추가로 무언가를 더 구현해야 할 때 더 용이하게 할 수 있는 등의 이점들이 있다.

## 2. React Testing Library에 대해서

CRA로 리액트 앱을 생성하면 기본적으로 테스팅할 때 React Testing Library를 사용하는 것을 볼 수 있다. 이 React Testing Library는 무엇일까?

### React Testing Library란 무엇인가?

React Testing Library는 React 구성 요소 작업을 위한 API를 추가하여 DOM Testing Library위에 구축된다.

DOM Testing Library란 DOM 노드를 테스트하기 위한 매우 가벼운 솔루션이다.

CRA로 생성된 프로젝트는 즉시 React Testing Library를 지원한다. 그렇지 않은 경우에는 다음과 같이 설치 가능하다

```bash
npm install --save-dev @testing-library/react
```

→ 리액트 컴포넌트를 테스트하는 가벼운 솔루션

RTL은 에어비앤비에서 만든 Enzyme을 대체하는 솔루션이다.

Enzyme는 개발자에게 React 구성 요소의 내부를 테스트할 수 있는 유틸리티를 제공하는 동안 React Testing Library는 한 걸음 물러서서 React 구성 요소를 테스트하여 React 구성 요소를 완전히 신뢰하는 방법에 대해 질문한다. 구성 요소의 구현 세부 정보를 테스트하는 대신 개발자를 React 애플리케이션의 사용자 입장에 둔다.

Enzyme : 구현 주도 테스트 (props 를 교환하는 거에 중점)

RTL : 행위 주도 테스트 (어떠한 행위가 일어지고 있는지 기능이 일어나고 있는지 사용자 입장에서의 테스트)

## 3. DOM이란?

Document Object Model(문서 객체 모델)은 XML, HTML 문서의 각 항목을 계층으로 표현하여 생성, 변형, 삭제할 수 있도록 돕는 인터페이스이다.

### 웹 페이지 빌드 과정(Critical Rendering Path CRP)

- 브라우저가 서버에서 페이지에 대한 HTML 응답을 받고 화면에 표시하기 전에 여러 단계가 있다.
- 웹 브라우저가 HTML 문서를 읽고, 스타일 입히고 뷰포트에 표시하는 과정이다.

순서

1. 문서를 읽어들여서 그것들을 파싱하고 어떤 내용을 페이지에 렌더링할 지 결정한다.(HTML,CSS,JS)
2. 브라우저가 DOM과 CSSOM을 결합하는 곳이며, 이 프로세스는 화면에 보이는 모든 콘텐츠의 콘텐츠와 스타일 정보를 모두 포함하는 최종 렌더링 트리를 출력한다. 즉 화면에 표시되는 모든 노드의 콘텐츠 및 스타일 정보를 포함한다.
3. 브라우저가 페이지에 표시되는 각 요소의 크기와 위치를 계산하는 단계이다.
4. 페인트 단계에 도달하면 브라우저는 레이아웃 결과를 선택하고 픽셀을 화면에 페인트 한다.

DOM

- HTML 요소들의 구조화된 표현
- DOM은 HTML이 브라우저의 렌더링 엔진에 의해 분석되고 분석이 모두 끝나고난 HTML 파일이 DOM이다.
- HTML은 화면에 보이고자 하는 모양과 구조를 문서로 만들어서 단순 텍스트로 구성되어 있으며 DOM은 HTML문서의 내용과 구조가 객체 모델로 변환되어 다양한 프로그램에서 사용될 수 있다.
- HTML 문서가 유효하지 않게 작성됐을때는 브라우저가 올바르게 교정해주며, DOM은 자바스크립트에 의해 수정될 수 있다. 하지만 HTML은 수정하지 않는다.

## 4. CRA로 리액트 시작하기

- 원래 리액트 앱을 처음 실행하기 위해선 webpack이나 babel같은 것을 설정하기 위해서 엄청 나게 많은 시간이 걸렸다.
- CRA를 사용하면 바로 시작 가능하다.

## 5. Jest에 대하여

Jest란 Facebook에서 만들어진 테스팅 프레임 워크이다. 최소한의 설정으로 동작하며 TestCase를 만들어서 어플리케이션 코드가 잘 돌아가는지 확인해준다. 단위(Unit)테스트를 위해 이용한다.

Test

- 단위 테스트 폴더(Unit Test)
    - 단위 테스트 파일: <대상 이름>.test.js
- 통합 테스트(Integration Test)
    - 통합 테스트 파일 : <대상 이름>.test.init.js

Jest가 Test 파일을 찾는 방법

- {filename}.test.js
- {filename}.spec.js
- All files inside tests folders

## 6. Jest 파일 구조 & 사용법

describe라는 것이 있고 test(it)라는 test case들이 모아져있다.

describe

- 여러 관련 테스트를 그룹화하는 블록을 만든다.

it(test)

- 개별 테스트를 수행하는 곳 각 테스트를 작은 문장처럼 설명한다.

expect

- expect 함수는 값을 테스트할 때마다 사용된다. expect 함수 혼자서는 거의 사용되지 않으며 matcher와 함께 사용한다.

matcher

- 다른 방법으로 값을 테스트 하도록 매처를 사용한다.

## 7. React Testing Library 주요 API

render 함수

- DOM에 컴포넌트를 렌더링하는 함수
- 인자로 렌더링 할 React 컴포넌트가 들어간다.
- Return은 RTL에서 제공하는 쿼리 함수와 기타 유틸리티 함수를 담고 있는 객체를 리턴(Destructuring 문법으로 원하는 쿼리 함수만 얻어올 수 있다.) ⇒ 소스코드가 복잡해지면 비추천!!! screen 객체를 사용하기. 왜냐면 사용해야할 쿼리가 많아질수록 코드가 복잡해질 수 있다.

```jsx
// 추천되지 않는 방법
test('renders learn react link', ()=>{
	const {getByText} = render(<App/>);
})

// screen이라는 객체를 이용해서 쿼리함수를 사용하면 됨.
```

## 8. 쿼리 함수에 대해서

쿼리는 페이지에서 요소를 찾기 위해 테스트 라이브러리가 제공하는 방법이다. 여러 유형의 쿼리("get", "find", "query")가 있다. 이들 간의 차이점은 요소가 발견되지 않으면 쿼리에서 오류가 발생하는지 또는 Promise를 반환하고 다시 시도하는지 여부이다. 선택하는 페이지 콘텐트에 따라 다른 쿼리가 다소 적절할 수 있다.

getBy...

- 쿼리에 대해 일치하는 노드를 반환하고 일치하는 요소가 없거나 둘 이상의 일치가 발견되면 설명 오류를 발생시킨다.(둘 이상의 요소가 예상되는 경우 대신 getAllBy를 사용한다.)

queryBy...

- 쿼리에 대해 일치하는 노드를 반환하고 일치하는 요소가 없으면 null을 반환한다. 이것은 존재하지 않는 요소를 어설션하는데 유용하다. 둘 이상의 일치 항목이 발견되면 오류가 발생한다.(확인된 경우 대신 queryAllBy를 사용)

findBy...

- 주어진 쿼리와 일치하는 요소가 발견되면 Promise를 반환한다. 요소가 발견되지 않거나 기본 제한 시간인 1000ms후에 둘 이상의 요소가 발견되면 약속이 거부된다. 둘 이상의 요소를 찾아야 하는 경우 findAllBy를 사용해야 한다.

getBy + waitFor = findBy

waitFor

- 일정 기간 동안 기다려야 할 때 waitFor을 사용하여 기대가 통과할때까지 기다릴 수 있다.